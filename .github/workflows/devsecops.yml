name:  DevSecOps Pipeline

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  release:
    types: [published]
  workflow_dispatch: 

permissions:
  contents: read
  security-events: write
  actions: read
  issues: write
  pull-requests: write
  id-token: write

jobs:

  # ========== PR & PUSH JOBS ==========
  trufflehog:
    name:  Secrets Scanning (TruffleHog)
    if: github.event_name == 'push' || github.event_name == 'pull_request'
    uses: ./.github/workflows/trufflehog.yml

  nmap:
    name:  Network Security (Nmap)
    if: github.event_name == 'push' || github.event_name == 'pull_request'
    uses: ./.github/workflows/nmap.yml
    secrets:
      SECRET_JWT: ${{ secrets.SECRET_JWT }}
      SECRET_KEY_AES: ${{ secrets.SECRET_KEY_AES }}
      MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
      OAUTH_GITHUB_CLIENT_ID: ${{ secrets.OAUTH_GITHUB_CLIENT_ID }}
      OAUTH_GITHUB_CLIENT_SECRET: ${{ secrets.OAUTH_GITHUB_CLIENT_SECRET }}

  zap-baseline:
    name:  ZAP Baseline Scan
    if: github.event_name == 'push' || github.event_name == 'pull_request'
    uses: ./.github/workflows/zap-baseline.yml
    secrets:
      SECRET_JWT: ${{ secrets.SECRET_JWT }}
      SECRET_KEY_AES: ${{ secrets.SECRET_KEY_AES }}
      MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
      OAUTH_GITHUB_CLIENT_ID: ${{ secrets.OAUTH_GITHUB_CLIENT_ID }}
      OAUTH_GITHUB_CLIENT_SECRET: ${{ secrets.OAUTH_GITHUB_CLIENT_SECRET }}
  
  sqlmap:
    name:  SQL Injection Scan (SQLMap)
    if: github.event_name == 'push' || github.event_name == 'pull_request'
    uses: ./.github/workflows/sqlmap.yml
    secrets:
      SECRET_JWT: ${{ secrets.SECRET_JWT }}
      SECRET_KEY_AES: ${{ secrets.SECRET_KEY_AES }}
      MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
      MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
      OAUTH_GITHUB_CLIENT_ID: ${{ secrets.OAUTH_GITHUB_CLIENT_ID }}
      OAUTH_GITHUB_CLIENT_SECRET: ${{ secrets.OAUTH_GITHUB_CLIENT_SECRET }}

  semgrep:
    name:  Static Analysis (Semgrep)
    if: github.event_name == 'release'
    uses: ./.github/workflows/semgrep.yml
    secrets:
      SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
 
  snyk:
    name:  Code Security (Snyk)
    if: github.event_name == 'release'
    uses: ./.github/workflows/snyk.yml
    secrets:
      SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  sonarqube:
    name:  Code Quality (SonarQube)
    if: github.event_name == 'release'
    uses: ./.github/workflows/sonarqube.yml
    secrets:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  # ========== SUMMARY REPORT ==========
  report-summary:
    name:  DevSecOps Summary
    runs-on: ubuntu-latest
    needs: []  # Î‘Ï…Ï„ÏŒ Î¸Î± Î³ÎµÎ¼Î¯ÏƒÎµÎ¹ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± Î±Ï€ÏŒ Ï„Î± available jobs
    if: github.event_name == 'pull_request'
    permissions:
      issues: write
      pull-requests: write
      contents: read
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Dynamic job discovery and summary
        uses: actions/github-script@v6
        with:
          script: |
            const runId = process.env.GITHUB_RUN_ID;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // Get current workflow run
            const { data: runData } = await github.rest.actions.getWorkflowRun({
              owner,
              repo,
              run_id: runId
            });
            
            // Get all jobs for this workflow run
            const { data: jobsData } = await github.rest.actions.listJobsForWorkflowRun({
              owner,
              repo,
              run_id: runId,
              filter: 'all'
            });
            
            // Filter only completed jobs (not skipped)
            const completedJobs = jobsData.jobs.filter(job => 
              job.conclusion !== 'skipped' && job.status === 'completed'
            );
            
            let md = `##  DevSecOps Pipeline - Scan Summary\n\n`;
            md += `**Workflow:** ${runData.name}\n`;
            md += `**Run:** [#${runId}](${runData.html_url})\n`;
            md += `**Trigger:** ${github.event_name}\n\n`;
            
            // Group jobs by status
            const byStatus = {
              success: [],
              failure: [],
              cancelled: [],
              neutral: []
            };
            
            completedJobs.forEach(job => {
              const status = job.conclusion || 'neutral';
              if (byStatus[status]) {
                byStatus[status].push(job);
              }
            });
            
            // Success section
            if (byStatus.success.length > 0) {
              md += `###  Successful (${byStatus.success.length})\n`;
              byStatus.success.forEach(job => {
                md += `- **${job.name}** - [Logs](${job.html_url})\n`;
              });
              md += '\n';
            }
            
            // Failure section  
            if (byStatus.failure.length > 0) {
              md += `###  Failed (${byStatus.failure.length})\n`;
              byStatus.failure.forEach(job => {
                md += `- **${job.name}** - [Logs](${job.html_url})\n`;
              });
              md += '\n';
            }
            
            // Summary
            md += `###  Summary\n`;
            md += `-  **Passed:** ${byStatus.success.length}\n`;
            md += `-  **Failed:** ${byStatus.failure.length}\n`;
            md += `-  **Skipped:** ${jobsData.jobs.length - completedJobs.length}\n\n`;
            
            md += `**Artifacts:** [Download reports](${runData.html_url})\n`;
            md += `**Security:** All scans completed successfully! ðŸŽ‰`;

            // Post comment to PR
            if (context.payload.pull_request) {
              const pr = context.payload.pull_request.number;
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pr,
                body: md
              });
            }